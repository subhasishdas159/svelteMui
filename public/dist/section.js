/* src/section.svelte generated by Svelte v3.20.1 */
import { SvelteComponentDev, add_flush_callback, add_location, append_dev, attr_dev, bind, binding_callbacks, create_component, destroy_component, detach_dev, dispatch_dev, element, init, insert_dev, mount_component, safe_not_equal, set_data_dev, space, text, transition_in, transition_out, validate_slots } from "/dist/web_modules/svelte/internal.js";
import "/dist/web_modules/focus-visible.js"; // import any components

import { Button, Checkbox } from "/dist/web_modules/svelte-mui.js";
const file = "src/section.svelte";

function add_css() {
  var style = element("style");
  style.id = "svelte-137s8qa-style";
  style.textContent = "h1.svelte-137s8qa{color:purple}\n/*# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoic2VjdGlvbi5zdmVsdGUiLCJzb3VyY2VzIjpbInNlY3Rpb24uc3ZlbHRlIl0sInNvdXJjZXNDb250ZW50IjpbIjxoMT5IZWxsbyB7bmFtZX0hPC9oMT5cclxuXHJcbjxDaGVja2JveCBiaW5kOmNoZWNrZWQ+Q2hlY2tib3g8L0NoZWNrYm94PlxyXG5cclxuPHA+Q2hlY2tib3ggaXMgPHN0cm9uZz57Y2hlY2tlZCA/ICdjaGVja2VkJyA6ICd1bmNoZWNrZWQnfTwvc3Ryb25nPjwvcD5cclxuXHJcbjxCdXR0b25cclxuICAgIG91dGxpbmVkXHJcbiAgICBzaGFwZWRcclxuICAgIGNvbG9yPVwiUmVkXCJcclxuICAgIG9uOmNsaWNrPXsoKSA9PiB7IGNoZWNrZWQgPSAhY2hlY2tlZCB9fVxyXG4+XHJcbiAgICBJbnZlcnNlXHJcbjwvQnV0dG9uPlxyXG5cclxuPHNjcmlwdD5cclxuICAgIGV4cG9ydCBsZXQgbmFtZTtcclxuICAgIC8vIG9wdGlvbmFsIGltcG9ydCBmb2N1cy12aXNpYmxlIHBvbHlmaWxsIG9ubHkgb25jZVxyXG4gICAgaW1wb3J0ICdmb2N1cy12aXNpYmxlJztcclxuICAgIC8vIGltcG9ydCBhbnkgY29tcG9uZW50c1xyXG4gICAgaW1wb3J0IHsgQnV0dG9uLCBDaGVja2JveCB9IGZyb20gJ3N2ZWx0ZS1tdWknO1xyXG5cclxuICAgIGxldCBjaGVja2VkID0gdHJ1ZTtcclxuPC9zY3JpcHQ+XHJcblxyXG48c3R5bGU+XHJcbiAgICBoMSB7XHJcbiAgICAgICAgY29sb3I6IHB1cnBsZTtcclxuICAgIH1cclxuPC9zdHlsZT4iXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBMEJJLEVBQUUsZUFBQyxDQUFDLEFBQ0EsS0FBSyxDQUFFLE1BQU0sQUFDakIsQ0FBQyJ9 */";
  append_dev(document.head, style);
} // (3:0) <Checkbox bind:checked>


function create_default_slot_1(ctx) {
  let t;
  const block = {
    c: function create() {
      t = text("Checkbox");
    },
    m: function mount(target, anchor) {
      insert_dev(target, t, anchor);
    },
    d: function destroy(detaching) {
      if (detaching) detach_dev(t);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot_1.name,
    type: "slot",
    source: "(3:0) <Checkbox bind:checked>",
    ctx
  });
  return block;
} // (7:0) <Button      outlined      shaped      color="Red"      on:click={() => { checked = !checked }}  >


function create_default_slot(ctx) {
  let t;
  const block = {
    c: function create() {
      t = text("Inverse");
    },
    m: function mount(target, anchor) {
      insert_dev(target, t, anchor);
    },
    d: function destroy(detaching) {
      if (detaching) detach_dev(t);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot.name,
    type: "slot",
    source: "(7:0) <Button      outlined      shaped      color=\\\"Red\\\"      on:click={() => { checked = !checked }}  >",
    ctx
  });
  return block;
}

function create_fragment(ctx) {
  let h1;
  let t0;
  let t1;
  let t2;
  let t3;
  let updating_checked;
  let t4;
  let p;
  let t5;
  let strong;
  let t6_value = (
  /*checked*/
  ctx[1] ? "checked" : "unchecked") + "";
  let t6;
  let t7;
  let current;

  function checkbox_checked_binding(value) {
    /*checkbox_checked_binding*/
    ctx[2].call(null, value);
  }

  let checkbox_props = {
    $$slots: {
      default: [create_default_slot_1]
    },
    $$scope: {
      ctx
    }
  };

  if (
  /*checked*/
  ctx[1] !== void 0) {
    checkbox_props.checked =
    /*checked*/
    ctx[1];
  }

  const checkbox = new Checkbox({
    props: checkbox_props,
    $$inline: true
  });
  binding_callbacks.push(() => bind(checkbox, "checked", checkbox_checked_binding));
  const button = new Button({
    props: {
      outlined: true,
      shaped: true,
      color: "Red",
      $$slots: {
        default: [create_default_slot]
      },
      $$scope: {
        ctx
      }
    },
    $$inline: true
  });
  button.$on("click",
  /*click_handler*/
  ctx[3]);
  const block = {
    c: function create() {
      h1 = element("h1");
      t0 = text("Hello ");
      t1 = text(
      /*name*/
      ctx[0]);
      t2 = text("!");
      t3 = space();
      create_component(checkbox.$$.fragment);
      t4 = space();
      p = element("p");
      t5 = text("Checkbox is ");
      strong = element("strong");
      t6 = text(t6_value);
      t7 = space();
      create_component(button.$$.fragment);
      attr_dev(h1, "class", "svelte-137s8qa");
      add_location(h1, file, 0, 0, 0);
      add_location(strong, file, 4, 15, 87);
      add_location(p, file, 4, 0, 72);
    },
    l: function claim(nodes) {
      throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    },
    m: function mount(target, anchor) {
      insert_dev(target, h1, anchor);
      append_dev(h1, t0);
      append_dev(h1, t1);
      append_dev(h1, t2);
      insert_dev(target, t3, anchor);
      mount_component(checkbox, target, anchor);
      insert_dev(target, t4, anchor);
      insert_dev(target, p, anchor);
      append_dev(p, t5);
      append_dev(p, strong);
      append_dev(strong, t6);
      insert_dev(target, t7, anchor);
      mount_component(button, target, anchor);
      current = true;
    },
    p: function update(ctx, [dirty]) {
      if (!current || dirty &
      /*name*/
      1) set_data_dev(t1,
      /*name*/
      ctx[0]);
      const checkbox_changes = {};

      if (dirty &
      /*$$scope*/
      16) {
        checkbox_changes.$$scope = {
          dirty,
          ctx
        };
      }

      if (!updating_checked && dirty &
      /*checked*/
      2) {
        updating_checked = true;
        checkbox_changes.checked =
        /*checked*/
        ctx[1];
        add_flush_callback(() => updating_checked = false);
      }

      checkbox.$set(checkbox_changes);
      if ((!current || dirty &
      /*checked*/
      2) && t6_value !== (t6_value = (
      /*checked*/
      ctx[1] ? "checked" : "unchecked") + "")) set_data_dev(t6, t6_value);
      const button_changes = {};

      if (dirty &
      /*$$scope*/
      16) {
        button_changes.$$scope = {
          dirty,
          ctx
        };
      }

      button.$set(button_changes);
    },
    i: function intro(local) {
      if (current) return;
      transition_in(checkbox.$$.fragment, local);
      transition_in(button.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(checkbox.$$.fragment, local);
      transition_out(button.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching) detach_dev(h1);
      if (detaching) detach_dev(t3);
      destroy_component(checkbox, detaching);
      if (detaching) detach_dev(t4);
      if (detaching) detach_dev(p);
      if (detaching) detach_dev(t7);
      destroy_component(button, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}

function instance($$self, $$props, $$invalidate) {
  let {
    name
  } = $$props;
  let checked = true;
  const writable_props = ["name"];
  Object.keys($$props).forEach(key => {
    if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console.warn(`<Section> was created with unknown prop '${key}'`);
  });
  let {
    $$slots = {},
    $$scope
  } = $$props;
  validate_slots("Section", $$slots, []);

  function checkbox_checked_binding(value) {
    checked = value;
    $$invalidate(1, checked);
  }

  const click_handler = () => {
    $$invalidate(1, checked = !checked);
  };

  $$self.$set = $$props => {
    if ("name" in $$props) $$invalidate(0, name = $$props.name);
  };

  $$self.$capture_state = () => ({
    name,
    Button,
    Checkbox,
    checked
  });

  $$self.$inject_state = $$props => {
    if ("name" in $$props) $$invalidate(0, name = $$props.name);
    if ("checked" in $$props) $$invalidate(1, checked = $$props.checked);
  };

  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }

  return [name, checked, checkbox_checked_binding, click_handler];
}

class Section extends SvelteComponentDev {
  constructor(options) {
    super(options);
    if (!document.getElementById("svelte-137s8qa-style")) add_css();
    init(this, options, instance, create_fragment, safe_not_equal, {
      name: 0
    });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "Section",
      options,
      id: create_fragment.name
    });
    const {
      ctx
    } = this.$$;
    const props = options.props || {};

    if (
    /*name*/
    ctx[0] === undefined && !("name" in props)) {
      console.warn("<Section> was created without expected prop 'name'");
    }
  }

  get name() {
    throw new Error("<Section>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }

  set name(value) {
    throw new Error("<Section>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }

}

export default Section;